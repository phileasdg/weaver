<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weaving Pattern Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Inconsolata&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f4; /* stone-100 */
        }
        .form-input:focus, .form-select:focus, .btn:focus-visible {
            outline: 2px solid #0d9488; /* teal-600 */
            outline-offset: 2px;
            --tw-ring-color: #0d9488;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            width: 2.25rem;
            height: 2.25rem;
            border: none;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch {
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #e7e5e4; /* stone-200 */
        }
        input[type="color"]::-moz-color-swatch {
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #e7e5e4; /* stone-200 */
        }
        input[type="color"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        #weavingCanvas {
            cursor: grab;
        }
        #weavingCanvas:active {
            cursor: grabbing;
        }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
          -webkit-appearance: none; 
          margin: 0; 
        }
        input[type=number] {
          -moz-appearance: textfield;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
    </style>
</head>
<body class="bg-stone-100 text-stone-800">

    <!-- Hamburger Button (for mobile) -->
    <button id="menuToggleBtn" class="lg:hidden fixed top-4 left-4 z-50 p-2 bg-white/70 backdrop-blur-sm rounded-full shadow-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-stone-800" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </button>
    
    <!-- Backdrop for mobile menu -->
    <div id="menuBackdrop" class="lg:hidden fixed inset-0 bg-black/30 z-30 hidden"></div>

    <div class="w-full h-screen p-0 lg:p-4">
        <div class="w-full h-full bg-white flex flex-col lg:flex-row overflow-hidden lg:rounded-2xl shadow-lg main-container">
        <!-- CONTROLS PANEL -->
        <aside id="controlsPanel" class="w-full max-w-sm lg:w-[26rem] p-6 sm:p-8 border-b lg:border-b-0 lg:border-r border-stone-200 flex flex-col flex-shrink-0 fixed lg:relative inset-y-0 left-0 z-40 bg-white transform -translate-x-full lg:translate-x-0 transition-transform duration-300 ease-in-out">
            <div>
                <h1 class="text-3xl font-bold text-teal-800 mb-2">Weaver's Canvas</h1>
                <p class="text-sm text-stone-600 mb-6">Create and visualize digital weaving patterns.</p>
            </div>
            
            <div id="accordion-container" class="flex-1 min-h-0 overflow-y-auto pr-4 -mr-4 space-y-1">
                <!-- Accordion Item 1: Project Setup -->
                <div class="border-b border-stone-200">
                    <button class="accordion-header flex justify-between items-center w-full py-4 text-left font-semibold text-stone-800">
                        <span>Project Setup</span>
                        <svg class="w-5 h-5 transition-transform transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
                    </button>
                    <div class="accordion-content">
                        <div class="pb-4 space-y-5">
                             <div>
                                <label for="warpThreads" class="block text-sm font-medium text-stone-700 mb-1">Warp Threads (Vertical)</label>
                                <input type="number" id="warpThreads" value="144" min="2" max="2000" class="form-input w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm focus:ring-teal-500 focus:border-teal-500 transition">
                            </div>
                            <div>
                                <label for="weftThreads" class="block text-sm font-medium text-stone-700 mb-1">Weft Threads (Horizontal)</label>
                                <input type="number" id="weftThreads" value="144" min="2" max="2000" class="form-input w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm focus:ring-teal-500 focus:border-teal-500 transition">
                            </div>
                            <div>
                                <label for="pattern" class="block text-sm font-medium text-stone-700 mb-1">Pattern Type</label>
                                <select id="pattern" class="form-select w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm focus:ring-teal-500 focus:border-teal-500 transition">
                                    <option value="plain">Plain Weave</option>
                                    <option value="twill">Twill</option>
                                    <option value="satin">Satin</option>
                                    <option value="basket">Basket Weave</option>
                                    <option value="tartan">Tartan (2/2 Twill)</option>
                                </select>
                            </div>
                            <div id="patternSettingsContainer" class="space-y-3 !mt-4 border-t border-stone-200 pt-4"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Accordion Item 2: Warp Sett -->
                <div class="border-b border-stone-200">
                     <button class="accordion-header flex justify-between items-center w-full py-4 text-left font-semibold text-stone-800">
                        <span>Warp Sett</span>
                        <svg class="w-5 h-5 transition-transform transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
                    </button>
                    <div class="accordion-content">
                        <div class="pb-4 space-y-5">
                            <div class="p-3 border border-stone-200 rounded-md max-h-48 overflow-y-auto">
                                <div id="warpColorsContainer" class="flex flex-col gap-2"></div>
                            </div>
                            <button id="addWarpColorBtn" class="btn text-sm w-full bg-stone-200 text-stone-700 font-semibold py-1.5 px-3 rounded-md hover:bg-stone-300 transition-colors shadow-sm border border-stone-300">
                                + Add Color
                            </button>
                            <label for="warpRepeat" class="block text-sm font-medium text-stone-700 mb-1">Warp Repeat Style</label>
                            <select id="warpRepeat" class="form-select w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm">
                                <option value="simple">Simple Repeat</option>
                                <option value="point">Point Repeat</option>
                                <option value="mirror">Mirror Repeat</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Accordion Item 3: Weft Sett -->
                <div class="border-b border-stone-200">
                     <button class="accordion-header flex justify-between items-center w-full py-4 text-left font-semibold text-stone-800">
                        <span>Weft Sett</span>
                        <svg class="w-5 h-5 transition-transform transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
                    </button>
                     <div class="accordion-content">
                        <div class="pb-4 space-y-5">
                             <div class="p-3 border border-stone-200 rounded-md max-h-48 overflow-y-auto">
                                <div id="weftColorsContainer" class="flex flex-col gap-2"></div>
                            </div>
                             <button id="addWeftColorBtn" class="btn text-sm w-full bg-stone-200 text-stone-700 font-semibold py-1.5 px-3 rounded-md hover:bg-stone-300 transition-colors shadow-sm border border-stone-300">
                                + Add Color
                            </button>
                            <label for="weftRepeat" class="block text-sm font-medium text-stone-700 mb-1">Weft Repeat Style</label>
                            <select id="weftRepeat" class="form-select w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm">
                                <option value="simple">Simple Repeat</option>
                                <option value="point">Point Repeat</option>
                                <option value="mirror">Mirror Repeat</option>
                            </select>
                        </div>
                    </div>
                </div>

                 <!-- Accordion Item 4: Randomizer -->
                <div class="border-b border-stone-200">
                     <button class="accordion-header flex justify-between items-center w-full py-4 text-left font-semibold text-stone-800">
                        <span>Randomizer</span>
                        <svg class="w-5 h-5 transition-transform transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
                    </button>
                     <div class="accordion-content">
                        <div class="pb-4 space-y-5">
                             <div>
                                <label for="paletteType" class="block text-xs font-medium text-stone-600 mb-1">Palette Type</label>
                                <select id="paletteType" class="form-select w-full text-sm px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm">
                                    <option value="analogous">Analogous</option>
                                    <option value="complementary" selected>Complementary</option>
                                    <option value="split_complementary">Split Complementary</option>
                                    <option value="triadic">Triadic</option>
                                    <option value="custom">Custom</option>
                                    <option value="random">Fully Random</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-stone-600 mb-1">Color Palette</label>
                                <div class="flex flex-col gap-2 p-2 bg-stone-100 rounded-md min-h-[3.5rem]">
                                    <div id="currentPaletteContainer" class="flex flex-row flex-wrap gap-2">
                                        <!-- Palette swatches will be added here by JS -->
                                    </div>
                                    <button id="addPaletteColorBtn" class="hidden btn text-xs w-full bg-stone-200 text-stone-700 font-semibold py-1 px-2 rounded hover:bg-stone-300 transition-colors border border-stone-300">
                                        + Add Palette Color
                                    </button>
                                </div>
                            </div>
                            <div class="flex gap-3">
                                <div class="flex-1">
                                    <label for="minPaletteSize" class="block text-xs font-medium text-stone-600 mb-1">Min Palette Size</label>
                                    <input type="number" id="minPaletteSize" value="2" min="1" class="form-input text-sm w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm" placeholder="2">
                                </div>
                                <div class="flex-1">
                                    <label for="maxPaletteSize" class="block text-xs font-medium text-stone-600 mb-1">Max Palette Size</label>
                                    <input type="number" id="maxPaletteSize" value="6" min="1" class="form-input text-sm w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm" placeholder="10">
                                </div>
                            </div>
                             <div class="flex gap-3">
                                <div class="flex-1">
                                    <label for="minSettEntries" class="block text-xs font-medium text-stone-600 mb-1">Min Sett Entries</label>
                                    <input type="number" id="minSettEntries" value="4" min="1" max="20" class="form-input text-sm w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm" placeholder="2">
                                </div>
                                <div class="flex-1">
                                    <label for="maxSettEntries" class="block text-xs font-medium text-stone-600 mb-1">Max Sett Entries</label>
                                    <input type="number" id="maxSettEntries" value="10" min="1" max="20" class="form-input text-sm w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm" placeholder="20">
                                </div>
                            </div>
                            <div class="flex gap-3">
                                <div class="flex-1">
                                    <label for="minThreads" class="block text-xs font-medium text-stone-600 mb-1">Min Threads</label>
                                    <input type="number" id="minThreads" value="4" min="1" max="100" class="form-input text-sm w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm" placeholder="1">
                                </div>
                                <div class="flex-1">
                                    <label for="maxThreads" class="block text-xs font-medium text-stone-600 mb-1">Max Threads</label>
                                    <input type="number" id="maxThreads" value="40" min="1" max="100" class="form-input text-sm w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm" placeholder="100">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
            <div class="pt-6 space-y-3">
                 <button id="randomizeBtn" class="btn w-full bg-amber-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-amber-600 active:bg-amber-700 transition-colors shadow-md hover:shadow-lg transform hover:-translate-y-0.5">
                        Generate Random
                    </button>
                <div class="flex gap-3">
                    <button id="resetViewBtn" class="btn w-full bg-stone-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-stone-600 active:bg-stone-700 transition-colors shadow-sm">
                        Reset View
                    </button>
                </div>
                 <button id="downloadBtn" class="btn w-full bg-teal-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-teal-700 active:bg-teal-800 transition-colors shadow-sm">
                    Download PNG
                </button>
            </div>
        </aside>

        <!-- VISUALIZATION AREA -->
        <main class="w-full flex-1 bg-stone-200 flex flex-col items-center justify-center relative overflow-hidden p-2 sm:p-4 lg:p-6">
             <div class="absolute top-2 left-2 text-xs text-stone-500 bg-stone-300/50 rounded-md px-2 py-1 pointer-events-none z-10">
                Scroll to zoom, drag to pan
            </div>
            <canvas id="weavingCanvas" class="bg-white rounded-lg shadow-inner w-full h-full"></canvas>
        </main>
        </div>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('weavingCanvas');
        const ctx = canvas.getContext('2d');
        const warpThreadsInput = document.getElementById('warpThreads');
        const weftThreadsInput = document.getElementById('weftThreads');
        const patternSelect = document.getElementById('pattern');
        const patternSettingsContainer = document.getElementById('patternSettingsContainer');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const randomizeBtn = document.getElementById('randomizeBtn');
        
        const warpColorsContainer = document.getElementById('warpColorsContainer');
        const addWarpColorBtn = document.getElementById('addWarpColorBtn');
        const weftColorsContainer = document.getElementById('weftColorsContainer');
        const addWeftColorBtn = document.getElementById('addWeftColorBtn');

        const warpRepeatSelect = document.getElementById('warpRepeat');
        const weftRepeatSelect = document.getElementById('weftRepeat');
        const currentPaletteContainer = document.getElementById('currentPaletteContainer');
        const addPaletteColorBtn = document.getElementById('addPaletteColorBtn');
        const paletteTypeSelect = document.getElementById('paletteType');

        // Mobile Menu Elements
        const menuToggleBtn = document.getElementById('menuToggleBtn');
        const controlsPanel = document.getElementById('controlsPanel');
        const menuBackdrop = document.getElementById('menuBackdrop');

        // Canvas transform state
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastX = 0;
        let lastY = 0;
        const MIN_ZOOM = 0.01;
        const MAX_ZOOM = 20;
        const BASE_CELL_SIZE = 20;

        // --- PATTERN GENERATION LOGIC ---
        function generatePlainWeave(warpCount, weftCount) {
            const matrix = [];
            for (let i = 0; i < weftCount; i++) {
                const row = [];
                for (let j = 0; j < warpCount; j++) {
                    row.push((i + j) % 2 === 0 ? 1 : 0);
                }
                matrix.push(row);
            }
            return matrix;
        }

        function generateTwill(warpCount, weftCount, over, under) {
            const step = over + under;
            if (step === 0) return generatePlainWeave(warpCount, weftCount);
            const matrix = [];
            for (let i = 0; i < weftCount; i++) {
                const row = [];
                for (let j = 0; j < warpCount; j++) {
                    row.push((j - i + warpCount * weftCount) % step < over ? 1 : 0);
                }
                matrix.push(row);
            }
            return matrix;
        }

        function generateSatin(warpCount, weftCount, harness) {
            if (harness < 2) harness = 2;
            const step = 2; 
            const matrix = [];
            for (let i = 0; i < weftCount; i++) {
                const row = [];
                const floatStart = (i * step) % harness;
                for (let j = 0; j < warpCount; j++) {
                    row.push(j % harness === floatStart ? 1 : 0);
                }
                matrix.push(row);
            }
            return matrix;
        }
        
        function generateBasketWeave(warpCount, weftCount, size) {
            if (size < 1) size = 1;
            const matrix = [];
            for (let i = 0; i < weftCount; i++) {
                const row = [];
                for (let j = 0; j < warpCount; j++) {
                    const isRowOver = Math.floor(i / size) % 2 === 0;
                    const isColOver = Math.floor(j / size) % 2 === 0;
                    row.push(isRowOver === isColOver ? 1 : 0);
                }
                matrix.push(row);
            }
            return matrix;
        }

        function expandSett(sett) {
            const sequence = [];
            sett.forEach(item => {
                for (let i = 0; i < item.count; i++) {
                    sequence.push(item.color);
                }
            });
            return sequence;
        }
        
        function expandColorSequence(colors, mode, length) {
            if (!colors || colors.length === 0) return Array(length).fill('#888888');
            const n = colors.length;
            let sequence = [];
            
            if (mode === 'simple') {
                sequence = colors;
            } else if (mode === 'point') {
                sequence = [...colors];
                if (n > 1) sequence.push(...colors.slice(0, -1).reverse());
            } else if (mode === 'mirror') {
                sequence = [...colors, ...[...colors].reverse()];
            }

            if (sequence.length === 0) return Array(length).fill('#888888');
            const expanded = [];
            for (let i = 0; i < length; i++) {
                expanded.push(sequence[i % sequence.length]);
            }
            return expanded;
        }

        // --- UI & DRAWING LOGIC ---
        function updatePatternSettingsUI() {
            const patternType = patternSelect.value;
            patternSettingsContainer.innerHTML = ''; 

            const createInput = (id, label, value, min = 1, max = 20) => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label for="${id}" class="block text-sm font-medium text-stone-700 mb-1">${label}</label>
                    <input type="number" id="${id}" value="${value}" min="${min}" max="${max}" class="form-input w-full px-3 py-2 bg-stone-50 border border-stone-300 rounded-md shadow-sm">
                `;
                div.querySelector('input').addEventListener('input', () => handleUIDrivenUpdate());
                return div;
            };

            switch (patternType) {
                case 'twill':
                    patternSettingsContainer.appendChild(createInput('twillOver', 'Over', 2));
                    patternSettingsContainer.appendChild(createInput('twillUnder', 'Under', 1));
                    break;
                case 'satin':
                    patternSettingsContainer.appendChild(createInput('satinHarness', 'Harness', 5, 3));
                    break;
                case 'basket':
                    patternSettingsContainer.appendChild(createInput('basketSize', 'Block Size', 2, 2));
                    break;
                case 'tartan': 
                case 'plain':
                    break;
            }
        }
        
        let patternMatrix = [];
        let expandedWarpColors = [];
        let expandedWeftColors = [];

        function getSettFromUI(container) {
            const colorEntries = container.querySelectorAll('.color-entry-wrapper');
            return Array.from(colorEntries).map(entry => {
                return {
                    color: entry.querySelector('input[type="color"]').value,
                    count: parseInt(entry.querySelector('input[type="number"]').value) || 1
                };
            });
        }

        function regenerateData() {
            const warpCount = parseInt(warpThreadsInput.value);
            const weftCount = parseInt(weftThreadsInput.value);
            const patternType = patternSelect.value;
            
            const warpRepeatMode = warpRepeatSelect.value;
            const weftRepeatMode = weftRepeatSelect.value;
            
            const warpSett = getSettFromUI(warpColorsContainer);
            const weftSett = getSettFromUI(weftColorsContainer);
            
            const parsedWarpColors = expandSett(warpSett);
            const parsedWeftColors = expandSett(weftSett);

            expandedWarpColors = expandColorSequence(parsedWarpColors, warpRepeatMode, warpCount);
            expandedWeftColors = expandColorSequence(parsedWeftColors, weftRepeatMode, weftCount);

            switch(patternType) {
                case 'tartan':
                    patternMatrix = generateTwill(warpCount, weftCount, 2, 2); // Tartan is a 2/2 twill
                    break;
                case 'plain': 
                    patternMatrix = generatePlainWeave(warpCount, weftCount); 
                    break;
                case 'twill': {
                    const over = parseInt(document.getElementById('twillOver')?.value || 2);
                    const under = parseInt(document.getElementById('twillUnder')?.value || 1);
                    patternMatrix = generateTwill(warpCount, weftCount, over, under);
                    break;
                }
                case 'satin': {
                    const harness = parseInt(document.getElementById('satinHarness')?.value || 5);
                    patternMatrix = generateSatin(warpCount, weftCount, harness);
                    break;
                }
                case 'basket': {
                    const size = parseInt(document.getElementById('basketSize')?.value || 2);
                    patternMatrix = generateBasketWeave(warpCount, weftCount, size);
                    break;
                }
                default: patternMatrix = generatePlainWeave(warpCount, weftCount);
            }
        }

        function fitToView() {
            const warpCount = parseInt(warpThreadsInput.value);
            if (warpCount === 0 || canvas.width === 0) return;

            const patternPixelWidth = warpCount * BASE_CELL_SIZE;
            zoom = (canvas.width / patternPixelWidth) * 0.9; // 90% scale for padding
            
            const patternPixelHeight = parseInt(weftThreadsInput.value) * BASE_CELL_SIZE;
            if (patternPixelHeight * zoom > canvas.height) {
                 zoom = (canvas.height / patternPixelHeight) * 0.9;
            }
            zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));

            const patternWidth = warpCount * BASE_CELL_SIZE * zoom;
            const patternHeight = parseInt(weftThreadsInput.value) * BASE_CELL_SIZE * zoom;
            offsetX = (canvas.width - patternWidth) / 2;
            offsetY = (canvas.height - patternHeight) / 2;
        }
        
        function drawPattern() {
            const warpCount = parseInt(warpThreadsInput.value);
            const weftCount = parseInt(weftThreadsInput.value);
            const cellSize = BASE_CELL_SIZE * zoom;
            
            if (canvas.width === 0 || canvas.height === 0) return;

            ctx.save();
            ctx.fillStyle = '#f5f5f4'; // Match panel bg
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.translate(offsetX, offsetY);
            
            if (!patternMatrix || patternMatrix.length === 0) return;

            // Simple culling for performance
            const startY = Math.floor(-offsetY / cellSize);
            const endY = Math.ceil((canvas.height - offsetY) / cellSize);
            const startX = Math.floor(-offsetX / cellSize);
            const endX = Math.ceil((canvas.width - offsetX) / cellSize);

            for (let i = Math.max(0, startY); i < Math.min(weftCount, endY); i++) {
                for (let j = Math.max(0, startX); j < Math.min(warpCount, endX); j++) {
                    if (patternMatrix[i][j] === 1) {
                        ctx.fillStyle = expandedWarpColors[j];
                    } else {
                        ctx.fillStyle = expandedWeftColors[i];
                    }
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize + 0.5, cellSize + 0.5);
                }
            }
            
            ctx.restore();
        }

        function updateColorNumbers(container) {
            const colorEntries = container.querySelectorAll('.color-entry-wrapper');
            colorEntries.forEach((entry, index) => {
                let numberSpan = entry.querySelector('.color-number');
                if (!numberSpan) {
                    numberSpan = document.createElement('span');
                    numberSpan.className = 'text-xs font-mono text-stone-500 w-6 text-center color-number flex-shrink-0';
                    entry.insertBefore(numberSpan, entry.firstChild);
                }
                numberSpan.textContent = `${index + 1}.`;
            });
        }


        function createColorPicker(container, colorValue = '#cccccc', countValue = 12) {
            const wrapper = document.createElement('div');
            wrapper.className = 'relative flex items-center group color-entry-wrapper gap-2 p-1 rounded-md hover:bg-stone-100 w-full';

            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = colorValue;
            
            const countInput = document.createElement('input');
            countInput.type = 'number';
            countInput.value = countValue;
            countInput.min = 1;
            countInput.max = 500;
            countInput.className = "w-14 text-sm text-center form-input px-1 py-1 bg-white border border-stone-300 rounded-md shadow-sm";
            countInput.setAttribute('aria-label', 'Thread count');

            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16"><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.647 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/></svg>`;
            removeBtn.className = 'ml-auto text-stone-400 hover:text-red-600 hover:bg-red-100 rounded-full p-0.5 transition-colors';
            removeBtn.setAttribute('aria-label', 'Remove color');
            
            colorInput.addEventListener('input', () => handleUIDrivenUpdate());
            countInput.addEventListener('input', () => handleUIDrivenUpdate());
            removeBtn.addEventListener('click', () => { 
                wrapper.remove(); 
                updateColorNumbers(container);
                handleUIDrivenUpdate(); 
            });
            
            wrapper.appendChild(colorInput);
            wrapper.appendChild(countInput);
            wrapper.appendChild(removeBtn);
            container.appendChild(wrapper);
        }
        
        // --- EVENT LISTENERS & ACTIONS ---
        function handleUIDrivenUpdate(shouldFitView = false) {
            const container = canvas.parentElement;
            if (container.clientWidth > 0 && container.clientHeight > 0) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }

            regenerateData();

            if (shouldFitView) {
                fitToView(); 
            }

            drawPattern(); 
        }
        
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        function parseInputWithFallback(inputId, fallbackType) {
            const input = document.getElementById(inputId);
            let value = parseInt(input.value, 10);
            if (isNaN(value) || input.value.trim() === '') {
                value = parseInt(input.getAttribute('placeholder'), 10) || (input[fallbackType] ? parseInt(input[fallbackType], 10) : NaN);
            }
            
            const min = parseInt(input.min, 10);
            const max = parseInt(input.max, 10);

            if (!isNaN(min) && value < min) {
                value = min;
            }
            if (!isNaN(max) && value > max) {
                value = max;
            }
            
            return value;
        }

        function setupMinMaxValidation() {
            const fields = [
                ['minPaletteSize', 'maxPaletteSize'],
                ['minSettEntries', 'maxSettEntries'],
                ['minThreads', 'maxThreads']
            ];

            fields.forEach(([minId, maxId]) => {
                const minInput = document.getElementById(minId);
                const maxInput = document.getElementById(maxId);

                minInput.addEventListener('change', () => {
                    const minValue = parseInt(minInput.value);
                    const maxValue = parseInt(maxInput.value);
                    if (!isNaN(minValue) && !isNaN(maxValue) && minValue > maxValue) {
                        minInput.value = maxValue;
                    }
                });

                maxInput.addEventListener('change', () => {
                    const minValue = parseInt(minInput.value);
                    const maxValue = parseInt(maxInput.value);
                    if (!isNaN(minValue) && !isNaN(maxValue) && maxValue < minValue) {
                        maxInput.value = minValue;
                    }
                });
            });
        }
        
        function createEditablePaletteSwatch(color) {
            const wrapper = document.createElement('div');
            wrapper.className = 'relative group';

            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = color;
            
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-x-lg text-white" viewBox="0 0 16 16"><path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z"/></svg>`;
            removeBtn.className = 'absolute -top-1.5 -right-1.5 p-0.5 rounded-full bg-red-500 hover:bg-red-600 transition-colors opacity-0 group-hover:opacity-100 focus:opacity-100';
            removeBtn.setAttribute('aria-label', 'Remove color');
            
            removeBtn.addEventListener('click', () => { 
                wrapper.remove(); 
            });
            
            let oldColor = color;
            colorInput.addEventListener('input', () => {
                if (paletteTypeSelect.value !== 'custom') return;
                const newColor = colorInput.value;
                
                // Find and replace color in the warp and weft sett UI
                const allSettInputs = [
                    ...warpColorsContainer.querySelectorAll('.color-entry-wrapper input[type="color"]'),
                    ...weftColorsContainer.querySelectorAll('.color-entry-wrapper input[type="color"]')
                ];
                allSettInputs.forEach(input => {
                    if (input.value === oldColor) {
                        input.value = newColor;
                    }
                });

                oldColor = newColor;
                handleUIDrivenUpdate();
            });

            wrapper.appendChild(colorInput);
            if (paletteTypeSelect.value === 'custom') {
                 wrapper.appendChild(removeBtn);
            } else {
                colorInput.disabled = true;
            }
            currentPaletteContainer.appendChild(wrapper);
        }

        function updateCurrentPaletteUI(palette) {
            currentPaletteContainer.innerHTML = '';
            palette.forEach(color => createEditablePaletteSwatch(color));
            
            const isCustom = paletteTypeSelect.value === 'custom';
            addPaletteColorBtn.classList.toggle('hidden', !isCustom);
            
             // Re-query for accordion content and update max-height if open
            const accordionContent = paletteTypeSelect.closest('.accordion-content');
            if (accordionContent && accordionContent.style.maxHeight) {
                accordionContent.style.maxHeight = accordionContent.scrollHeight + "px";
            }
        }

        function generateHarmonizedPalette() {
            const paletteType = paletteTypeSelect.value;
            
            const minPaletteSize = parseInputWithFallback('minPaletteSize', 'min');
            const maxPaletteSize = parseInputWithFallback('maxPaletteSize', 'max');
            const paletteSize = Math.floor(Math.random() * (maxPaletteSize - minPaletteSize + 1)) + minPaletteSize;

            const palette = [];
            const baseHue = Math.random() * 360;
            let hues = [baseHue];

            switch (paletteType) {
                case 'analogous':
                    for (let i = 1; i < paletteSize; i++) hues.push((baseHue + (Math.random() - 0.5) * 60 + 360) % 360);
                    break;
                case 'complementary':
                    if (paletteSize > 1) hues.push((baseHue + 180) % 360);
                    for (let i = 2; i < paletteSize; i++) hues.push((hues[Math.floor(Math.random()*hues.length)] + (Math.random() - 0.5) * 45 + 360) % 360);
                    break;
                case 'split_complementary':
                     if (paletteSize > 1) hues.push((baseHue + 150) % 360);
                     if (paletteSize > 2) hues.push((baseHue + 210) % 360);
                     for (let i = 3; i < paletteSize; i++) hues.push((hues[Math.floor(Math.random()*hues.length)] + (Math.random() - 0.5) * 30 + 360) % 360);
                    break;
                case 'triadic':
                    if (paletteSize > 1) hues.push((baseHue + 120) % 360);
                    if (paletteSize > 2) hues.push((baseHue + 240) % 360);
                    for (let i = 3; i < paletteSize; i++) hues.push((hues[Math.floor(Math.random()*hues.length)] + (Math.random() - 0.5) * 30 + 360) % 360);
                    break;
                case 'custom': 
                case 'random':
                default:
                    for (let i = 1; i < paletteSize; i++) hues.push(Math.random() * 360);
                    break;
            }
            
            hues = hues.slice(0, paletteSize);

            for (let i = 0; i < paletteSize; i++) {
                const hue = hues[i % hues.length];
                const sat = Math.floor(Math.random() * 30) + 50; // 50-80%
                const light = Math.floor(Math.random() * 30) + 40; // 40-70%
                palette.push(hslToHex(hue, sat, light));
            }
            return palette;
        }

        function generateRandomPattern() {
            const minSettEntries = parseInputWithFallback('minSettEntries', 'min');
            const maxSettEntries = parseInputWithFallback('maxSettEntries', 'max');
            const minThreads = parseInputWithFallback('minThreads', 'min');
            const maxThreads = parseInputWithFallback('maxThreads', 'max');
            const numEntries = Math.floor(Math.random() * (maxSettEntries - minSettEntries + 1)) + minSettEntries;

            const patternTypes = ['plain', 'twill', 'satin', 'basket', 'tartan'];
            patternSelect.value = patternTypes[Math.floor(Math.random() * patternTypes.length)];
            
            const generateSettFromPalette = (palette, numEntries, minThreads, maxThreads) => {
                if (palette.length === 0) return [];
                const sett = [];
                let lastColor = null;

                const requiredColors = [...palette].sort(() => 0.5 - Math.random());

                for (let i = 0; i < numEntries; i++) {
                    let nextColor;
                    if (requiredColors.length > 0) {
                        nextColor = requiredColors.pop();
                        if (nextColor === lastColor && requiredColors.length > 0) {
                            requiredColors.unshift(nextColor);
                            nextColor = requiredColors.pop();
                        }
                    }
                    
                    if (!nextColor || nextColor === lastColor) {
                        const availableColors = palette.filter(c => c !== lastColor);
                        if (availableColors.length > 0) {
                            nextColor = availableColors[Math.floor(Math.random() * availableColors.length)];
                        } else {
                            nextColor = palette[0];
                        }
                    }

                    sett.push({
                        color: nextColor,
                        count: Math.floor(Math.random() * (maxThreads - minThreads + 1)) + minThreads
                    });
                    lastColor = nextColor;
                }
                return sett;
            };
            
            warpColorsContainer.innerHTML = '';
            weftColorsContainer.innerHTML = '';
            
            let colorPalette;
            if (paletteTypeSelect.value === 'custom') {
                const customColorInputs = currentPaletteContainer.querySelectorAll('input[type="color"]');
                colorPalette = Array.from(customColorInputs).map(input => input.value);
                if (colorPalette.length === 0) {
                    colorPalette = ['#cc0000', '#00cc00', '#0000cc']; // Default if empty
                }
            } else {
                colorPalette = generateHarmonizedPalette();
            }
            updateCurrentPaletteUI(colorPalette);

            const warpSett = generateSettFromPalette(colorPalette, numEntries, minThreads, maxThreads);
            const weftSett = Math.random() > 0.5 ? warpSett : generateSettFromPalette(colorPalette, numEntries, minThreads, maxThreads);

            warpSett.forEach(p => createColorPicker(warpColorsContainer, p.color, p.count));
            updateColorNumbers(warpColorsContainer);
            weftSett.forEach(p => createColorPicker(weftColorsContainer, p.color, p.count));
            updateColorNumbers(weftColorsContainer);
            
            const repeatTypes = ['simple', 'point', 'mirror'];
            warpRepeatSelect.value = repeatTypes[Math.floor(Math.random() * repeatTypes.length)];
            weftRepeatSelect.value = repeatTypes[Math.floor(Math.random() * repeatTypes.length)];
            
            updatePatternSettingsUI();
            handleUIDrivenUpdate(true);
        }
        
        // --- GLOBAL EVENT LISTENERS ---
        function toggleMenu() {
            controlsPanel.classList.toggle('-translate-x-full');
            const isHidden = menuBackdrop.classList.toggle('hidden');
            document.body.style.overflow = isHidden ? '' : 'hidden';
            // Allow a moment for the panel to be visible before resizing canvas
            setTimeout(() => handleUIDrivenUpdate(true), 50); 
        }

        menuToggleBtn.addEventListener('click', toggleMenu);
        menuBackdrop.addEventListener('click', toggleMenu);

        warpThreadsInput.addEventListener('input', () => handleUIDrivenUpdate(true));
        weftThreadsInput.addEventListener('input', () => handleUIDrivenUpdate(true));
        warpRepeatSelect.addEventListener('input', () => handleUIDrivenUpdate());
        weftRepeatSelect.addEventListener('input', () => handleUIDrivenUpdate());
        
        patternSelect.addEventListener('change', () => { updatePatternSettingsUI(); handleUIDrivenUpdate(); });
        addWarpColorBtn.addEventListener('click', () => { 
            createColorPicker(warpColorsContainer); 
            updateColorNumbers(warpColorsContainer);
            handleUIDrivenUpdate(); 
        });
        addWeftColorBtn.addEventListener('click', () => { 
            createColorPicker(weftColorsContainer); 
            updateColorNumbers(weftColorsContainer);
            handleUIDrivenUpdate(); 
        });
        
        addPaletteColorBtn.addEventListener('click', () => {
             createEditablePaletteSwatch('#888888');
             updateCurrentPaletteUI(Array.from(currentPaletteContainer.querySelectorAll('input[type="color"]')).map(i => i.value));
        });

        paletteTypeSelect.addEventListener('change', (e) => {
            const isCustom = e.target.value === 'custom';
            if (isCustom) {
                // Keep current palette when switching to custom
                updateCurrentPaletteUI(Array.from(currentPaletteContainer.querySelectorAll('input[type="color"]')).map(i => i.value));
            } else {
                // Generate a new palette for other types
                updateCurrentPaletteUI(generateHarmonizedPalette());
            }
        });
        
        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `weaving-pattern-${patternSelect.value}.png`;
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const warpCount = parseInt(warpThreadsInput.value);
            const weftCount = parseInt(weftThreadsInput.value);
            tempCanvas.width = warpCount * BASE_CELL_SIZE;
            tempCanvas.height = weftCount * BASE_CELL_SIZE;

            regenerateData(); // Ensure color data is current

            for (let i = 0; i < weftCount; i++) {
                for (let j = 0; j < warpCount; j++) {
                    if (patternMatrix[i][j] === 1) tempCtx.fillStyle = expandedWarpColors[j];
                    else tempCtx.fillStyle = expandedWeftColors[i];
                    tempCtx.fillRect(j * BASE_CELL_SIZE, i * BASE_CELL_SIZE, BASE_CELL_SIZE, BASE_CELL_SIZE);
                }
            }
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        });

        resetViewBtn.addEventListener('click', () => { handleUIDrivenUpdate(true); });
        randomizeBtn.addEventListener('click', generateRandomPattern);

        canvas.addEventListener('mousedown', (e) => { isPanning = true; lastX = e.clientX; lastY = e.clientY; });
        canvas.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            offsetX += e.clientX - lastX;
            offsetY += e.clientY - lastY;
            lastX = e.clientX;
            lastY = e.clientY;
            drawPattern();
        });
        canvas.addEventListener('mouseup', () => isPanning = false);
        canvas.addEventListener('mouseleave', () => isPanning = false);
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const zoomFactor = 1.1;
            const oldZoom = zoom;
            if (e.deltaY < 0) zoom = Math.min(MAX_ZOOM, zoom * zoomFactor);
            else zoom = Math.max(MIN_ZOOM, zoom / zoomFactor);
            offsetX = mouseX - (mouseX - offsetX) * (zoom / oldZoom);
            offsetY = mouseY - (mouseY - offsetY) * (zoom / oldZoom);
            drawPattern();
        });

        // Initial setup on page load
        window.addEventListener('load', () => {
            // Set up the click behavior for all accordion headers first
            document.querySelectorAll('.accordion-header').forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const svg = header.querySelector('svg');

                    // If it's already open, close it
                    if (content.style.maxHeight) {
                        content.style.maxHeight = null;
                        svg.style.transform = 'rotate(0deg)';
                    } else {
                        // Close all other accordions
                        document.querySelectorAll('.accordion-content').forEach(c => {
                            c.style.maxHeight = null;
                            c.previousElementSibling.querySelector('svg').style.transform = 'rotate(0deg)';
                        });
                        
                        // Open the clicked one by setting its max-height based on its content
                        content.style.maxHeight = content.scrollHeight + "px";
                        svg.style.transform = 'rotate(180deg)';
                    }
                });
            });
            
            // Now run the initial setup
            setupMinMaxValidation();
            generateRandomPattern(); // This populates all dynamic UI content
        });
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                handleUIDrivenUpdate(true)
            }, 100);
        });
    </script>
</body>
</html>